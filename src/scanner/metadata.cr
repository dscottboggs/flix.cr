# Flix -- A media server in the Crystal Language with Kemal.cr
# Copyright (C) 2018 D. Scott Boggs
# See LICENSE.md for the terms of the AGPL under which this software can be used.
require "./filepath_operations"
require "./mime_type"

module Flix
  module Scanner
    # The interface that all directory and media files implement and default
    # methods on those files.
    abstract class FileMetadata
      include FilepathOperations
      @name : String?
      @hash : String?
      @stat : File::Info?
      @mime_type : MimeType?
      getter mime_type
      property name : String do
        get_title_from path
      end
      # the hash (unique id) of the filepath as generated by the Scanner
      getter hash : String do
        Scanner.hash @path
      end
      property path : String
      property parent : MediaDirectory? = nil
      property thumbnail : PhotoFile?

      def initialize(@path : String,
                     @stat : File::Info? = nil,
                     @thumbnail : PhotoFile? = nil,
                     @parent : MediaDirectory? = nil)
        @name = get_title_from @path
      end

      # returns false; Directory overloads this with true
      def is_dir?
        false
      end

      def quick_stat : File::Info
        @stat || stat
      end

      def stat : File::Info
        @stat = File.info path
      end

      # `File.basename(path)`
      @[AlwaysInline]
      def filename
        File.basename path
      end

      def mime_type
        @mime_type ||= MimeType.of path
      end

      def mime_type!
        @mime_type ||= MimeType.of! path
      end

      # The mime type of the current file as a string
      def textual_mime_type : String?
        mime_type.try &.to_s
      end

      # Detect the filetype of the given file, and store it as a class which
      # implements FileMetadata.
      #
      # This method is basically the heart of the Scanner module. It recursively
      # searches the root directories, associating all files underneath each
      # directory with its parent, indexing them by the MD5 hash of their
      # absolute filepath for later reference.
      def self.from_file_path?(filepath : String, stat : Crystal::System::FileInfo? = nil) : FileMetadata?
        if info = File.info? filepath # skip everything if the file is not valid
          if info.file? && (mime_type = MimeType.of filepath)
            if mime_type.is_a_video?
              # we got a video file!
              return VideoFile.new path: filepath, stat: info
            elsif mime_type.is_a_photo?
              # we got a picture!
              return PhotoFile.new path: filepath, stat: info
            elsif mime_type.could_be_subtitles?
              # We got a plain-text file which might contain subtitles
              if subs_class = Subtitles.detect file: filepath
                subs = SubtitleFile.new path: filepath
                subs.mime_type = SubtitleFile.mime_type of: subs_class
                return subs
              end
              return
            else
              return
            end
          end
          # We have a directory...
          out_dir = MediaDirectory.new path: filepath, stat: info
          # ...so it's time to recursively check-out all the files in this
          # directory.
          Dir.each_child dirname: filepath do |file|
            fullpath = File.join filepath, file
            info = File.info fullpath

            if new_file = from_file_path? fullpath
              case new_file.mime_type
              when nil then nil # ignore invalid files
              when .is_a_dir? then out_dir << new_file.as MediaDirectory
              when .is_a_photo? then out_dir << new_file.as PhotoFile
              when .is_a_video? then out_dir << new_file.as VideoFile
              when .is_a_subtitle? then out_dir << new_file.as SubtitleFile
              end
            end
          end

          return out_dir.which_has_only_subtitles! if out_dir.has_only_subtitles?
          # returns the first video in out_dir's children if out_dir only has one child video.
          return out_dir.first_video.using_all_subtitles_in(out_dir) if out_dir.size == 1
          out_dir.associate_subtitles!
          out_dir.associate_thumbnails!
          out_dir
        end
      end

      abstract def clone

      abstract def config_data

      def merge!(with config : ConfigData) : self
        @name = config.title
        self
      end
    end
  end
end

require "./metadata/*"
