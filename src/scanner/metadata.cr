# Flix -- A media server in the Crystal Language with Kemal.cr
# Copyright (C) 2018 D. Scott Boggs
# See LICENSE.md for the terms of the AGPL under which this software can be used.
require "yaml"
require "./mime_type"

module Flix
  module Scanner
    # The interface that all directory and media files implement and default
    # methods on those files.
    abstract class FileMetadata
      class_property all_photos = {} of String => PhotoFile
      class_property all_videos = {} of String => VideoFile
      property path : String
      @name : String?
      setter name : String
      @hash : String?
      @stat : File::Info?
      property thumbnail : PhotoFile?
      property parent : MediaDirectory? = nil
      @mime_type : MimeType?

      def initialize(@path : String,
                     @stat : File::Info? = nil,
                     @thumbnail : PhotoFile? = nil)
        @name = FileMetadata.get_title_from @path
      end

      private setter name

      # returns false; Directory overloads this with true
      def is_dir?
        false
      end

      def name : String
        @name ||= FileMetadata.get_title_from path
      end

      # the hash of the filepath as generated by the Scanner
      def hash : String
        @hash ||= Scanner.hash @path
      end

      def quick_stat : File::Info
        if @stat.nil?
          @stat = stat
        else
          @stat
        end
      end

      def stat : File::Info
        @stat = File.info path
      end

      def _filename
        File.basename path
      end

      # Just the section at the end of the filename after the final '.', if that
      # dot is less than 5 characters from the end of the filename. Nillable!
      def self.extension(of_this filename) : String?
        dot_loc = path.rindex '.'
        if dot_loc && dot_loc >= (path.size - 5)
          path[dot_loc..-1]
        end
      end

      # The filename without its `#extension` component. If the `#extension` is
      # `nil`, this is the whole filename.
      def self.without_extension(filename)
        dot_loc = filename.rindex '.'
        if dot_loc && dot_loc >= (filename.size - 5)
          filename[0..dot_loc]
        else
          filename
        end
      end

      def extension
        extension of_this: _filename
      end

      def without_extension
        without_extension _filename
      end

      def to_s
        %{<"#{name}"@#{path}$#{hash}>}
      end

      def mime_type
        @mime_type ||= MimeType.of path
      end

      def mime_type!
        @mime_type ||= MimeType.of! path
      end

      # The mime type of the current file as a string
      def textual_mime_type
        if mt = mime_type
          mt.to_s
        end
      end

      # Uses some heuristics to parse a human-readable title from some common
      # filename conventions.
      #
      # If there are any spaces in the filename this step is skipped and the
      # filename is used verbatim.
      def self.get_title_from(filepath : String) : String
        underscores, dots = 0_u32, 0_u32
        filename = File.basename filepath
        # trim off the extension
        if filename.size - (index = filename.rindex('.') || 0) <= 5
          filename = filename[0..index - 1]
        end
        # count dots and underscores
        filename.each_char do |char|
          # also check for spaces, since we're already iterating over all of them
          return filename if char == ' '
          dots += 1 if char == '.'
          underscores += 1 if char == '_'
        end
        # replace underscores or dots, depending on which has more
        if underscores > 0 || dots > 0
          subchar = if underscores > dots
                      '_'
                    else
                      '.'
                    end
          return filename
            .gsub(/\\#{subchar}([a-zA-Z])/) { |ss, match| " " + match[0].upcase }
            .gsub(subchar, ' ')
            .gsub(/\s+/, " ")
            .strip
        end
        # no spaces, dots, or underscores, so that leaves us with CamelCase
        filename = filename.gsub '-', " -"
        subs = Hash(Char, Char | String).new
        ('A'..'Z').each { |l| subs[l] = " " + l }
        filename = filename.sub 0, filename[0].upcase

        filename.gsub(subs).strip
      end

      # abstract def self.from_file_path?

      def to_json
        JSON.build { |builder| to_json builder }
      end

      def to_json(builder : JSON::Builder)
        builder.object { builder.field name: hash, value: name }
      end

      abstract def clone

      # ### <<<<     Configuration serialization section     >>>> #####

      # A convenience structure for converting to YAML.
      class ConfigData
        include YAML::Serializable
        # The human-readable title of the associated file, which may be
        # overridden.
        property title : String

        # An assiciated thumbnail. Nil by default. Subclasses which are
        # able to associate thumbnails should override this.
        def thumbnail
          nil
        end

        # :nodoc:
        def content
          nil
        end

        def initialize(from file : FileMetadata)
          @title = file.name
        end
      end

      abstract def config_data

      def merge!(with config : ConfigData) : self
        @name = config.title
        self
      end
    end
  end
end
